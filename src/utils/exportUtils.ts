// Export utilities for Islamic Dataset Interface
// Handles PDF, CSV, and JSON exports of search results

import type { UnifiedSearchResult } from "../types/Types";
import type { FilterState } from "../types/Types";

export interface ExportOptions {
  format: "pdf" | "csv" | "json";
  includeMetadata?: boolean;
  filename?: string;
  title?: string;
}

export interface ExportData {
  results: UnifiedSearchResult[];
  searchQuery?: string;
  filters?: FilterState;
  timestamp: string;
  totalResults: number;
}

// Generate filename with timestamp
const generateFilename = (baseName: string, format: string): string => {
  const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, "-");
  return `${baseName}_${timestamp}.${format}`;
};

// Export to CSV format
export const exportToCSV = (data: ExportData): void => {
  const { results, searchQuery, timestamp, totalResults } = data;

  // CSV headers
  const headers = [
    "Title",
    "Type",
    "Source",
    "Content",
    "Relevance Score",
    "Timestamp",
  ];

  // Convert results to CSV rows
  const rows = results.map((result) => [
    `"${result.title || ""}"`,
    `"${result.type || ""}"`,
    `"${result.source || ""}"`,
    `"${(result.content || "").replace(/"/g, '""')}"`,
    result.relevance || 0,
    result.timestamp?.toISOString() || timestamp,
  ]);

  // Combine headers and rows
  const csvContent = [
    headers.join(","),
    ...rows.map((row) => row.join(",")),
  ].join("\n");

  // Add metadata as comments
  const metadata = [
    `# Islamic Dataset Export`,
    `# Search Query: ${searchQuery || "N/A"}`,
    `# Total Results: ${totalResults}`,
    `# Export Date: ${timestamp}`,
    `# Generated by Islamic Dataset Interface`,
    "",
    csvContent,
  ].join("\n");

  // Create and download file
  const blob = new Blob([metadata], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = generateFilename("islamic_data_export", "csv");
  link.click();
  URL.revokeObjectURL(link.href);
};

// Export to JSON format
export const exportToJSON = (data: ExportData): void => {
  const exportData = {
    metadata: {
      title: "Islamic Dataset Export",
      searchQuery: data.searchQuery,
      totalResults: data.totalResults,
      exportDate: data.timestamp,
      generatedBy: "Islamic Dataset Interface",
    },
    results: data.results,
    filters: data.filters,
  };

  const jsonContent = JSON.stringify(exportData, null, 2);
  const blob = new Blob([jsonContent], {
    type: "application/json;charset=utf-8;",
  });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = generateFilename("islamic_data_export", "json");
  link.click();
  URL.revokeObjectURL(link.href);
};

// Export to PDF format (using jsPDF)
export const exportToPDF = async (data: ExportData): Promise<void> => {
  try {
    // Dynamic import to avoid bundle size issues
    const { jsPDF } = await import("jspdf");
    const doc = new jsPDF();

    const { results, searchQuery, timestamp, totalResults } = data;

    // Set up document
    doc.setFont("helvetica");
    doc.setFontSize(16);

    // Title
    doc.text("Islamic Dataset Export", 20, 20);

    // Metadata
    doc.setFontSize(10);
    doc.text(`Search Query: ${searchQuery || "N/A"}`, 20, 35);
    doc.text(`Total Results: ${totalResults}`, 20, 42);
    doc.text(`Export Date: ${timestamp}`, 20, 49);
    doc.text("Generated by Islamic Dataset Interface", 20, 56);

    // Results table
    let yPosition = 70;
    const pageHeight = 280;
    const lineHeight = 8;

    results.forEach((result, index) => {
      // Check if we need a new page
      if (yPosition > pageHeight) {
        doc.addPage();
        yPosition = 20;
      }

      // Result title
      doc.setFontSize(12);
      doc.setFont("helvetica", "bold");
      doc.text(`${index + 1}. ${result.title || "Untitled"}`, 20, yPosition);
      yPosition += lineHeight;

      // Result details
      doc.setFontSize(10);
      doc.setFont("helvetica", "normal");
      doc.text(`Type: ${result.type || "Unknown"}`, 25, yPosition);
      yPosition += lineHeight;
      doc.text(`Source: ${result.source || "Unknown"}`, 25, yPosition);
      yPosition += lineHeight;

      // Content preview (truncated)
      const content = (result.content || "").substring(0, 100);
      if (content) {
        doc.text(
          `Content: ${content}${content.length >= 100 ? "..." : ""}`,
          25,
          yPosition
        );
        yPosition += lineHeight;
      }

      yPosition += 5; // Extra spacing between results
    });

    // Save the PDF
    doc.save(generateFilename("islamic_data_export", "pdf"));
  } catch (error) {
    if (import.meta.env.DEV) {
      // eslint-disable-next-line no-console
      console.error("PDF export failed:", error);
    }
    // Fallback to JSON if PDF fails
    exportToJSON(data);
  }
};

// Main export function
export const exportData = async (
  data: ExportData,
  options: ExportOptions
): Promise<void> => {
  try {
    switch (options.format) {
      case "csv":
        exportToCSV(data);
        break;
      case "json":
        exportToJSON(data);
        break;
      case "pdf":
        await exportToPDF(data);
        break;
      default:
        throw new Error(`Unsupported export format: ${options.format}`);
    }
  } catch (error) {
    if (import.meta.env.DEV) {
      // eslint-disable-next-line no-console
      console.error("Export failed:", error);
    }
    throw error;
  }
};

// Generate shareable link
export const generateShareableLink = (data: ExportData): string => {
  const shareData = {
    query: data.searchQuery,
    results: data.results.length,
    timestamp: data.timestamp,
  };

  const encodedData = btoa(JSON.stringify(shareData));
  return `${window.location.origin}${window.location.pathname}?share=${encodedData}`;
};

// Parse shareable link
export const parseShareableLink = (): ExportData | null => {
  const urlParams = new URLSearchParams(window.location.search);
  const shareData = urlParams.get("share");

  if (!shareData) return null;

  try {
    const decodedData = JSON.parse(atob(shareData));
    return {
      results: [],
      searchQuery: decodedData.query,
      timestamp: decodedData.timestamp,
      totalResults: decodedData.results,
    };
  } catch (error) {
    if (import.meta.env.DEV) {
      // eslint-disable-next-line no-console
      console.error("Failed to parse shareable link:", error);
    }
    return null;
  }
};
